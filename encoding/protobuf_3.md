# Protobuf 3.0 - 编码

## 1. 前言

Protobuf 是 G 厂开源的序列化数据的方法，可以用来作为通信协议或者存储数据。它采用 IDL 这种中立的方式来描述数据接口，使得不同语言编写的程序可以根据同一接口来相互通信。不同编程语言也可以根据 IDL 的描述来生成对应数据结构，并用来编解码二进制数据流。为此，G 厂为主流开发语言都提供代码生成器（即 protoc ）。

为了更好地了解一些细节，本文将主要描述 Proobuf 3.0 的编码规则。

> Protobuf 采用是 Little Endian 的方式编码。

## 2. 热身

Protobuf 里面主要采用 Varint 和 Zig-Zag 的方式来对整型数字进行编码。在理解 Protobuf 之前，需要先了解这两种编码方式。

## 2.1 Varints

int64, int32, uint64, uint32 都有固定的二进制位数。

如果将这些数字序列化成二进制流的时候，需要额外空间告知接收方数据的长度。

对于采用 int64, uint64 这两种类型的数据而言，如果大部分时间都只是使用较小的数值，那么会极大地浪费传输带宽和存储空间。

针对这两个问题，Protobuf 采用 Varints 的编码方式。Varints 每次编码会以 **7 bit** 为一组，通过 **MSB (Most Significant Bit)** 来判断是否还存在后续字节流。

```
64 = 0100 0000 
	=> 0100 0000
```

64 有效位为 7 bit，正好可以符合 Varints 分组，而且不需要额外的字节，所以 MSB 比特位为 0。

```
16657 = 0100 0001 0001 0001
	=>  000 0001 ++  000 0010 ++ 001 0001
	=>  1000 0001 ++ 1000 0010 ++ 0001 0001
```

16657 有效位为 15 bit，需要分成三组字节，前两组字节为了提示还存在后续字节，所以前两组字节的 MSB 比特位为 1。

> Leading Zero 并不会编码。

Varints 不仅可以压缩小数值的编码大小，还可以简化了协议的定义，而且还能在不改协议的情况下平滑地升级到 128 bit 的整型。

不过面对带有符号的整型数值时，Varints 显得比较乏力，面对负数，Leading One 比特并不能被忽略。所以一旦遇到负数时，Varints 并不能起到压缩作用。

 > int32 的负数需要 5 字节，int64 的负数需要 10 字节。


## 2.2 Zig-Zag





