Interface in Go
Based on go1.8rc1
Tags: Golang, Interface, Data Structure

Wei Fu
fhfuwei@163.com

* What is interface?

* What is interface?

An interface type is defined as a set of method signatures.

.play src/interface/example1.go

* What is interface?

Support polymorphism with [[https://en.wikipedia.org/wiki/Duck_typing][Duck Typing]]

- Dynamic typing
- Reflection

* How does interface work in Go?

* Interface values

.image img/interface/interfaceValue.svg

source

- [[https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/runtime2.go#L143][iface]]
- [[https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/runtime2.go#L638][itab]]
- [[https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/type.go#L28][_type]], [[https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/type.go#L342][interfaceValue]]

* Interface values - Example

.play src/interface/example2.go

* Interface values - Example explaination

A copy of data

  (gdb) i locals
  &i = 0xc42000e2a0
  a = {tab = 0x1107200 <MyInt,main.Valuer>, data = 0xc42000e2a8}

  (gdb) x/x 0xc42000e2a0
  0xc42000e2a0:   0x0000000a

  (gdb) x/x 0xc42000e2a8
  0xc42000e2a8:   0x0000000a

Interface value

.image img/interface/explainInterfaceValue.svg

* Interface values - Examle explaination

itab is pair (interface type, concrete type) which generated by compiler.

The caller will look up the unbound variable `iface.tab.fun` for the call.

If there is dynamic type conversion, it seems that it is impossible to precompute
all possible pairs for itab!!!

So, how about dynamic type conversion?

* Dynamic type conversion

Global runtime hash table for pair (interface type, concrete type)

- [[https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/iface.go#L146][itabsinit]] : init hash table before start program
- [[https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/iface.go#L22][itabhash]] : hash key compute
- [[https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/iface.go#L33][getitab]] : find the itab
- [[https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/iface.go#L87][additab]] : add the itab into hash table

* Dynamic type conversion

The concrete type must all methods defined by the interface type.

The concrete type has *nc* number of methods and the interface type has *ni* number of methods. It seems that it takes O(nc * ni) time to do validation.

But the gopher does it better. The compiler sorts the method table for the concrete type and the interface type respectively. So, it only takes O(nc + ni).

* Dynamic type conversion - Example

.play src/interface/example3.go

* Dynamic type conversion - Example explaination

key point in assemble code

  0x10871a4       e80745f8ff          ALL runtime.assertE2I2(SB)

[[https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/iface.go#L289][assertE2I2]]

 func assertE2I2(inter *interfacetype, e eface) (r iface, b bool) {
    t := e._type
    if t == nil {
        return
    }
    tab := getitab(inter, t, true)
    if tab == nil {
        return
    }
    r.tab = tab
    r.data = e.data
    b = true
    return
 }

* Empty interface

* Empty interface

eface, not iface. It is memory saver.

.image img/interface/emptyInterfaceValue.svg

* Empty interface - Example

.play src/interface/example4.go

* Empty interfaces - Example explaination

  (gdb) i locals
  i = 10
  ver = {tab = 0x1107200 <MyInt,main.Valuer>, data = 0xc42000e2a8}
  eface = {_type = 0x1099c80 <type.*+76128>, data = 0xc42000e2a0}

  (gdb) p ver.tab._type
  $2 = (runtime._type *) 0x1099c80 <type.*+76128>
